Серверные/клиентские приложения
Основными механизмами настройки клиент-сервера являются:

1. Клиентское приложение отправляет запрос серверному приложению.
2. Серверное приложение возвращает ответ.
3. Некоторые из основных способов передачи данных между клиентом и сервером:
    1. Передача файлов – отправляет имя и получает файл.
    2. Веб-страница — отправляет URL-адрес и получает страницу.
    3. Эхо — отправляет сообщение и получает его обратно.

Серверный сокет
1. создать сокет — получить дескриптор файла!
2. привязка к адресу - На каком порту я нахожусь?
3. прослушайте порт и дождитесь установления соединения.
4. принять соединение от клиента.
5. send/recv — так же, как мы читаем и записываем файл.
6. выключение для завершения чтения/записи.
7. close to releases data.


Клиентский сокет
1. создать сокет .
2. привязка* — возможно, в этом нет необходимости, поскольку вы клиент, а не сервер.
3. подключитесь к серверу.
4. send/recv — повторять, пока не получим или не получим данные
5. выключение для завершения чтения/записи.
6. close to releases data

Socket - summary
Вот краткое изложение ключевых понятий:

1. Сокет — это способ общения с другими программами с использованием стандартных файловых дескрипторов .
2. Откуда нам взять дескриптор файла для сетевого взаимодействия?
Итак, мы вызываем системную процедуру Socket() .
После того, как методocket() возвращает дескриптор сокета, мы начинаем взаимодействовать через него, используя специализированные вызовы API сокетов send()/recv() .
3. TCP-сокет — это экземпляр конечной точки.
4. TCP-сокет — это не соединение , а конечная точка определенного соединения.
5. TCP- соединение определяется двумя конечными точками , называемыми сокетами.
6. Назначение портов — различать несколько конечных точек по данному сетевому адресу.
7. Номера портов закодированы в заголовке пакета транспортного протокола и могут быть легко интерпретированы не только отправляющими и принимающими компьютерами, но и другими компонентами сетевой инфраструктуры. В частности, брандмауэры обычно настраиваются так, чтобы различать пакеты на основе номеров их портов источника и назначения , как при переадресации портов .
8. Это пара сокетов ( кортеж из четырех элементов , состоящий из IP-адреса клиента, номера порта клиента, IP-адреса сервера и номера порта сервера), которая определяет две конечные точки, которые однозначно идентифицируют каждое TCP-соединение в Интернете.
9. Только один процесс может быть привязан к определенному IP-адресу и комбинации портов , используя один и тот же транспортный протокол . В противном случае возникнут конфликты портов , когда несколько программ пытаются подключиться к одним и тем же номерам портов на одном и том же IP-адресе, используя один и тот же протокол.

Для подключения к другой машине нам понадобится сокетное соединение.

Какая связь?

Отношения между двумя машинами, при которых две части программного обеспечения знают друг о друге . Эти две части программного обеспечения знают, как взаимодействовать друг с другом. Другими словами, они знают, как отправлять биты друг другу.
Соединение через сокет означает, что две машины имеют информацию друг о друге, включая сетевое местоположение (IP-адрес) и TCP-порт . (Если мы можем использовать аналогию, IP-адрес — это номер телефона , а TCP-порт — это расширение ).
Сокет — это объект, похожий на файл, который позволяет программе принимать входящие соединения, устанавливать исходящие соединения, а также отправлять и получать данные. Прежде чем две машины смогут взаимодействовать, обе должны создать объект сокета .

Сокет — это ресурс , назначенный серверному процессу. Сервер создает его с помощью системного вызова socket() , и его нельзя использовать совместно с другими процессами.

TCP против UDP
Существует несколько различных типов сокетов, определяющих структуру транспортного уровня. Наиболее распространенными типами являются потоковые сокеты и дейтаграммные сокеты.

Сокеты в компьютерных сетях бывают двух основных типов: потоковые (stream sockets) и дейтаграммные (datagram sockets). Они обеспечивают разные методы передачи данных и имеют свои особенности:

1. Потоковые сокеты (Stream Sockets):

Такие сокеты обеспечивают надежное, ориентированное на поток соединение.
Основанные на протоколе TCP (Transmission Control Protocol).
Гарантируют, что данные будут доставлены в правильном порядке и без потерь.
Подходят для передачи данных, где важна надежность и сохранение порядка, например, веб-сайты, электронная почта, файловые передачи и другие приложения.
Создание соединения требует установления связи между клиентом и сервером.

2. Дейтаграммные сокеты (Datagram Sockets):

Такие сокеты предоставляют более простой способ передачи данных без необходимости создания постоянного соединения.
Основаны на протоколе UDP (User Datagram Protocol).
Не гарантируют сохранение порядка и доставку данных; некоторые пакеты могут быть потеряны или доставлены в неправильном порядке.
Подходят для задач, где скорость и меньшая нагрузка на сеть важнее надежности, например, видеоконференции, онлайн-игры и другие приложения, где короткие и быстрые передачи данных важны.
Оба типа сокетов (потоковые и дейтаграммные) используются в сетевом программировании для обеспечения обмена данными между компьютерами по сети. Выбор между ними зависит от конкретных требований вашего приложения: надежности и сохранения порядка (потоковые сокеты) или скорости и минимизации задержек (дейтаграммные сокеты).

Сокеты в контексте сетевого программирования часто ассоциируют с файловыми дескрипторами, потому что в системах, основанных на системе UNIX, сокеты управляются с помощью файловых дескрипторов. Это делает их использование удобным и подобным работе с файлами. Однако важно понимать, что сокеты - это абстракция, предоставляемая операционной системой для сетевого взаимодействия, и они могут включать как сетевые дескрипторы, так и дополнительные данные, такие как адреса и порты.

Фактически, в операционной системе Linux и других UNIX-подобных системах, сокеты действительно реализованы как файловые дескрипторы, и это обуславливает их работу с системами ввода/вывода. Открытие сокета возвращает файловый дескриптор, с которым можно работать так же, как с файлами. Например, вы можете использовать функции read() и write(), чтобы читать и записывать данные из/в сокет, что делает работу с сокетами похожей на работу с файлами.

Поэтому сокеты обычно называют "дескрипторами сокетов", чтобы подчеркнуть, что они могут быть использованы для ввода/вывода данных, как файловые дескрипторы. Это удобно, так как разработчики могут использовать знакомые средства для работы с данными, хотя на самом деле они работают с данными, передаваемыми по сети.

Шаги по установке сокета на стороне сервера :

1. Создайте сокет с помощью системного вызова Socket().
2. Серверный процесс дает сокету имя. В файловой системе Linux локальным сокетам присваиваются имена файлов в каталоге /tmp или /usr/tmp. Для сетевых сокетов имя файла будет идентификатором службы и номером порта, к которому клиенты могут подключиться. Этот идентификатор позволяет маршрутизировать входящие соединения (которые имеют номер порта) для подключения к серверному процессу. Имя сокета присваивается с помощью системного вызова bind().
3. Затем серверный процесс ожидает подключения клиента к именованному сокету, который в основном прослушивает соединения с помощью системного вызова Listen() . Если несколько клиентов пытаются установить соединение, системный вызов Listen() создает очередь.
Машина, получающая соединение (сервер), должна привязать свой объект сокета к известному номеру порта. Порт — это 16-битное число в диапазоне 0–65535, которое управляется операционной системой и используется клиентами для уникальной идентификации серверов. Порты 0–1023 зарезервированы системой и используются обычными сетевыми протоколами.
4. Примите соединение с помощью системного вызова Accept() . В методе Accept() создается новый сокет, отличный от именованного сокета. Этот новый сокет используется исключительно для связи с этим конкретным клиентом.
Для TCP-серверов объект сокета, используемый для получения соединений, не является тем же самым сокетом, который используется для последующего взаимодействия с клиентом. В частности, системный вызов Accept() возвращает новый объект сокета, который фактически используется для соединения. Это позволяет серверу одновременно управлять соединениями от большого количества клиентов.
5. Отправка и получение данных.
6. Именованный сокет остается для дальнейших подключений от других клиентов. Типичный веб-сервер может использовать несколько соединений. Другими словами, он может обслуживать страницы множеству клиентов одновременно. Но для простого сервера дальнейшие клиенты ждут в очереди на прослушивание, пока сервер снова не будет готов.

Шаги по установке сокета на стороне клиента :

1. Создайте сокет с помощью системного вызова Socket().
2. Подключите сокет к адресу сервера с помощью системного вызова Connect() .
3. Отправка и получение данных. Есть несколько способов сделать это, но самый простой — использовать системные вызовы read() и write() .


Сокеты в C ведут себя как файлы, поскольку для идентификации они используют файловые дескрипторы. Сокеты настолько похожи на файлы, что мы можем использовать read() и write() для получения и отправки данных с помощью файловых дескрипторов сокетов .

Однако существует несколько функций, специально предназначенных для работы с сокетами. Прототипы этих функций определены в /usr/include/sys/sockets.h .

1. int socket(int domain, int type, int protocol)
Используется для создания нового сокета. Возвращает файловый дескриптор сокета или -1 в случае ошибки.
Он принимает три параметра:
    домен: семейство протоколов запрашиваемого сокета.
    type: тип сокета в этом семействе
    и протокол.

Параметры позволяют нам указать, какой сокет нам нужен (IPv4/IPv6, поток/дейтаграмма (TCP/UDP)).
Семейство протоколов должно быть AF_INET или AF_INET6.
и тип протокола для этих двух семейств —
SOCK_STREAM для TCP/IP или SOCK_DGRAM для UDP/IP.
Протокол обычно должен быть установлен на ноль, чтобы указать, что следует использовать протокол по умолчанию.

Сокеты были разработаны для обеспечения стандартизированного способа взаимодействия между приложениями через сети. Они обеспечивают абстракцию для сетевого взаимодействия и позволяют приложениям обмениваться данными через сеть, независимо от того, находятся они на одной машине или на разных устройствах в сети. Сокеты позволяют приложениям:

Устанавливать соединения с другими приложениями, как локально, так и удаленно.
Передавать данные между приложениями на разных устройствах.
Обеспечивать надежность передачи данных и обработку ошибок.
Сервер и клиент в сетевой модели общаются между собой через сокеты. Это сетевые точки, через которые происходит обмен данными. В этой модели сервер ожидает запросы на своем соксете и отвечает на них, а клиент устанавливает соединение с сервером, отправляет запросы и получает ответы.

Соксеты предоставляют унифицированный интерфейс для взаимодействия, независимо от среды выполнения. Они также позволяют приложениям работать с различными протоколами (например, TCP, UDP) и в разных операционных системах, обеспечивая переносимость кода.

В отношении вашего вопроса о сервере, он не может обращаться на прямую к другим устройствам или программам в сети, потому что это нарушит модель безопасности и изоляции приложений. Сокеты и сетевые протоколы предоставляют стандартизированный способ обмена данными между сервером и клиентами, что обеспечивает контроль доступа и безопасность обмена данными.

2. int bind(int fd, struct sockaddr *local_addr, socklen_t addr_length)
Если у нас есть сокет, нам, возможно, придется связать этот сокет с портом на нашей локальной машине.
Номер порта используется ядром для сопоставления входящего пакета с дескриптором сокета определенного процесса.
Сервер вызовет bind() указав адрес локального хоста и порт, на котором он будет прослушивать соединения.
Он принимает дескриптор файла (ранее установленный сокет), указатель на (адрес) структуры, содержащей сведения об адресе для привязки, для этого обычно используется значение INADDR_ANY и длину структуры адреса.
Конкретная структура, которую необходимо использовать, будет зависеть от протокола, поэтому она передается указателем.
Таким образом, bind() привяжет сокет к текущему IP-адресу порта, portno
Возвращает 0 в случае успеха и -1 в случае ошибки.

Этот код выполняет привязку (binding) сокета к определенному сетевому адресу и порту с использованием функции bind. Он важен для серверного приложения, чтобы сервер мог "слушать" определенный сетевой адрес и порт и принимать входящие соединения на этот адрес и порт. Давайте разберем, для чего это нужно по шагам:

1. bind() выполняет привязку сокета к конкретному сетевому адресу и порту. В данном случае, serv_addr - это структура struct sockaddr_in, которая представляет сетевой адрес и порт, к которым вы хотите привязать сокет.

2. Если bind() успешно завершается, это означает, что сервер будет прослушивать входящие соединения на указанном сетевом адресе и порту. Это важно для того, чтобы входящие клиенты знали, куда они должны отправлять свои запросы.

3. Если bind() не удается (например, из-за занятости указанного порта или ошибок в параметрах), то программа выводит сообщение об ошибке с помощью perror(), и, вероятно, завершает выполнение (в данном случае с вызовом exit()).

После успешного вызова bind(), серверный сокет готов к принятию входящих соединений, и вы можете продолжить, вызвав listen() для установки его в режим прослушивания и ожидания клиентов.

3. int listen(int fd, int backlog_queue_size)
После того как сервер привязан к адресу, он может вызвать метод Listen() для сокета.
Параметрами этого вызова являются сокет (fd) и максимальное количество запросов на соединения в очереди до backlog_queue_size .
Возвращает 0 в случае успеха и -1 в случае ошибки.

При вызове listen сервер начинает прослушивать на определенном соксете (вашем sockfd) входящие соединения от клиентов. Аргумент backlog указывает, сколько клиентов могут находиться в очереди на соединение. Если количество клиентов, ожидающих соединение, превышает это значение, то они получат сообщение о том, что сервер переполнен или занят.

Этот параметр полезен для управления нагрузкой на сервер. Если серверу приходит больше запросов, чем он может обработать одновременно, оставшиеся запросы помещаются в очередь и будут обработаны по мере освобождения ресурсов. Таким образом, это контролирует, сколько клиентов может ожидать соединения, пока сервер занят обслуживанием других клиентов.

Обычно выбор значения backlog зависит от потребностей конкретного сервера и его ресурсов. В больших и высоконагруженных серверах значение backlog может быть значительно больше.

4. int Accept (int fd, struct sockaddr *remote_host, socklen_t addr_length)
Принимает входящее соединение через связанный сокет. Информация об адресе удаленного хоста записывается в структуру Remote_host , а фактический размер структуры адреса записывается в *addr_length .
Другими словами, эта функция Accept() запишет информацию об адресе подключающегося клиента в структуру адреса.
Затем возвращает новый дескриптор файла сокета для принятого соединения.
Таким образом, исходный дескриптор файла сокета может продолжать использоваться для приема новых соединений, в то время как новый дескриптор файла сокета используется для связи с подключенным клиентом.
Эта функция возвращает новый дескриптор файла сокета для идентификации подключенного сокета или -1 в случае ошибки.

Вот описание на странице руководства:
«Он извлекает первый запрос на соединение из очереди ожидающих соединений для прослушивающего сокета, sockfd , создает новый подключенный сокет и возвращает новый дескриптор файла, ссылающийся на этот сокет. Вновь созданный сокет не находится в состоянии прослушивания. Исходный сокет sockfd не затрагивается этим вызовом".

Если в очереди нет ожидающих соединений и сокет не помечен как неблокирующий, метод Accept() блокирует вызывающую сторону до тех пор, пока не будет установлено соединение .

5. int Connect (int fd, struct sockaddr *remote_host, socklen_t addr_length)
Подключает сокет (описываемый файловым дескриптором fd ) к удаленному хосту.
Возвращает 0 в случае успеха и -1 в случае ошибки.

Это блокирующий вызов . Это связано с тем, что когда мы вызываем функцию connect(), наша программа не восстанавливает управление до тех пор, пока не будет установлено соединение или не произойдет ошибка. Например, предположим, что мы пишем веб-браузер. Мы пытаемся подключиться к веб-серверу, но сервер не отвечает. Итак, теперь мы хотим, чтобы API-интерфейс Connect() прекратил попытки подключения, нажав кнопку остановки. Но этого нельзя сделать. Он ожидает возврата, который может быть 0 в случае успеха или -1 в случае ошибки.

6. int send(int fd, void *buffer, size_t n, int flags)
Отправляет n байт из *buffer в сокет fd .
Возвращает количество отправленных байтов или -1 в случае ошибки.

7. int receive(int fd, void *buffer, size_t n, int flags)
Возвращает n байт из сокета fd в *buffer .
Возвращает количество полученных байтов или -1 в случае ошибки.

Это еще один блокирующий вызов . Другими словами, когда мы вызываем функцию Recv() для чтения из потока, управление не возвращается нашей программе до тех пор, пока хотя бы один байт данных не будет прочитан с удаленного сайта. Этот процесс ожидания появления данных называется блокировкой . То же самое относится и к API write(), Connect() и т. д. Когда мы запускаем эти блокирующие API, соединение «блокируется» до тех пор, пока операция не завершится.



